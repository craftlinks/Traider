import asyncio
# ---------------------------------------------------------------------------
# Standard library imports
# ---------------------------------------------------------------------------
from concurrent.futures import ProcessPoolExecutor
from datetime import datetime
import os
import pprint
import random
import signal
import time
from typing import Any, Optional
import uuid

# Models
from traider.yfinance._models import PressRelease
from traider.yfinance import EarningsEvent
# Use the shared message-bus infrastructure
from traider.messagebus.channels import Channel
from traider.messagebus.protocol import MessageBroker
from traider.messagebus.brokers.memory import InMemoryBroker
from traider.messagebus.router import MessageRouter

import logging
logging.basicConfig(level=logging.INFO)

def _cpu_bound_worker_fn(message: EarningsEvent) -> None:
    pprint.pprint(
        f"worker 2: Also received earnings event {message.id} for company: {message.company_name}"
    )
    time.sleep(1)
    return None


# ---------------------------------------------------------------------------
# Message-bus router and worker definitions
# ---------------------------------------------------------------------------


msg_broker: MessageBroker = InMemoryBroker()
router = MessageRouter(msg_broker)

# ---------------------------------------------------------------------------
# Channel listeners
# ---------------------------------------------------------------------------


# A global process pool for CPU-bound work – will be initialised in main().
process_pool_global: ProcessPoolExecutor | None = None


@router.route(listen_to=Channel.EARNINGS)
async def earnings_sink(event: EarningsEvent, shutdown_event: asyncio.Event) -> EarningsEvent | None:
    """Kick off a poller to retrieve the press-release that follows *event*."""

    pprint.pprint(f"[earnings_sink] Triggering poller for {event.company_name}")
    # Start a background poller that will automatically be cancelled when the
    # router shuts down because it is spawned via `router.spawn_task`.
    router.spawn_task(
        earnings_press_release_poller(msg_broker, event.company_name, event.ticker, shutdown_event)
    )

    # Example of reacting to global shutdown
    if shutdown_event.is_set():
        return None
    return None


#--------------------------------------------------------------------
# A worker that consumes press-release messages generated by the poller
#--------------------------------------------------------------------


@router.route(listen_to=Channel.PRESS_RELEASE)
async def press_release_worker(message: PressRelease, shutdown_event: asyncio.Event) -> None:
    """Process a press-release once it has been published."""

    pprint.pprint(
        f"[press_release_worker] Received press release for {message.ticker} — {message.title}"
    )
    # Demonstrate awareness of shutdown
    if shutdown_event.is_set():
        return None


# @router.route(listen_to=Channel.EARNINGS)
# async def cpu_heavy_worker(event: EarningsEvent, shutdown_event: asyncio.Event) -> EarningsEvent | None:
#     """Handle CPU-bound work in a separate process pool."""

#     assert process_pool_global is not None  # Should be initialised in *main*.
#     loop = asyncio.get_running_loop()
#     await loop.run_in_executor(process_pool_global, _cpu_bound_worker_fn, event)
#     if shutdown_event.is_set():
#         return None
#     return event


@router.route(publish_to=Channel.EARNINGS)
async def earnings_producer(broker: MessageBroker, shutdown_event: asyncio.Event, startup_barrier: asyncio.Barrier):
    """Generate dummy earnings events until MAX_EVENTS then trigger shutdown."""

    await startup_barrier.wait()  # Ensure all subscribers are ready

    for ticker in ["AAPL", "MSFT", "GOOG", "AMZN"]:
        if shutdown_event.is_set():
            break

        earnings_event = EarningsEvent(
            id=uuid.uuid4().int,
            ticker=ticker,
            company_name=ticker,
            event_name=f"{ticker} Earnings",
            time_type="after_hours",
            earnings_call_time=datetime.now(),
            eps_estimate=random.random() * 10,
            eps_actual=random.random() * 10,
            eps_surprise=random.random() * 10,
            eps_surprise_percent=random.random() * 10,
            market_cap=random.random() * 1000000000,
        )

        await broker.publish(Channel.EARNINGS, earnings_event)
        await asyncio.sleep(1)

    # shutdown_event.set()
    # logging.debug("Producer shutting down...")


async def earnings_press_release_poller(broker: MessageBroker, company_name: str, ticker: str, shutdown_event: asyncio.Event):
    """Simulate polling for a press-release that follows an earnings event.

    Runs in the background; prints a status line every half-second until either
    the press-release is "found" (after a few iterations) or a global shutdown
    request is detected.
    """

    for i in range(5):
        if shutdown_event.is_set():
            pprint.pprint(
                f"[press_release_poller] Cancelled for {company_name} – shutdown requested"
            )
            return

        await asyncio.sleep(0.5)
        pprint.pprint(
            f"[press_release_poller] Polling attempt {i+1} for {company_name} ({ticker})"
        )

    pprint.pprint(
        f"[press_release_poller] Press-release found for {company_name} ({ticker})"
    )

    # Craft a dummy press-release payload and publish it to the message-bus.
    press_release_msg = PressRelease(
        ticker=ticker,
        title=f"{company_name} beats EPS expectations",
        url="https://example.com/press-release",
        type="earnings",
        pub_date=datetime.now().isoformat(),
        company_name=company_name,
    )

    await broker.publish(Channel.PRESS_RELEASE, press_release_msg)


async def main() -> None:

    global process_pool_global

    shutdown_event = asyncio.Event()

    # Handle graceful shutdown via SIGINT / SIGTERM.
    loop = asyncio.get_running_loop()
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, shutdown_event.set)

    cpu_cores = os.cpu_count() or 1
    process_pool_global = ProcessPoolExecutor(max_workers=cpu_cores)


    # Barrier must cover subscribers + producers
    worker_count = router.node_count
    startup_barrier = asyncio.Barrier(parties=worker_count)

    async with asyncio.TaskGroup() as tg:
        tg.create_task(router.run(shutdown_event, startup_barrier))

    # Clean-up once all tasks are done.
    process_pool_global.shutdown(wait=True)
    logging.info("Main task complete")


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.debug("Shutting down...")